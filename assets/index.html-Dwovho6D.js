import{_ as t,c as a,a as i,o as n}from"./app-BPmJL-vo.js";const r="/images/um-cv/14-1.png",s="/images/um-cv/14-2.png",o="/images/um-cv/14-3.png",c="/images/um-cv/14-4.png",l="/images/um-cv/14-5.png",g="/images/um-cv/14-6.png",m="/images/um-cv/14-7.png",p="/images/um-cv/14-8.png",d="/images/um-cv/14-9.png",h="/images/um-cv/14-10.png",u="/images/um-cv/14-11.png",v="/images/um-cv/14-12.png",y="/images/um-cv/14-13.png",f="/images/um-cv/14-14.png",b="/images/um-cv/14-15.png",x="/images/um-cv/14-16.png",w="/images/um-cv/14-17.png",_="/images/um-cv/14-18.png",S="/images/um-cv/14-19.png",T="/images/um-cv/14-20.png",k="/images/um-cv/14-21.png",z="/images/um-cv/14-22.png",A="/images/um-cv/14-23.png",F="/images/um-cv/14-24.png",N="/images/um-cv/14-25.png",C="/images/um-cv/14-26.png",D="/images/um-cv/14-27.png",G="/images/um-cv/14-28.png",I="/images/um-cv/14-29.png",V="/images/um-cv/14-30.png",M={};function P(E,e){return n(),a("div",null,[...e[0]||(e[0]=[i('<p>Various techniques to visualize and understand CNNs. <strong>Activations:</strong> Nearest neighbors, PCA, t-SNE, saliency, occlusion, backpropagation. <strong>Gradients:</strong> Saliency maps, class visualization, fooling images, feature inversion. <strong>Fun:</strong> DeepDream, texture synthesis, style transfer.</p><p>@Credits: <a href="https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/" target="_blank" rel="noopener noreferrer">EECS 498.007</a> | Video Lecture: <a href="https://www.youtube.com/watch?v=dJYGatp4SvA&amp;list=PL5-TkQAfAZFbzxjBHtzdVCWE0Zbhomg7r" target="_blank" rel="noopener noreferrer">UM-CV</a></p><p>Personal work for the assignments of the course: <a href="https://github.com/SaturnTsen/EECS-498-007/" target="_blank" rel="noopener noreferrer">github repo</a>.</p><p><strong>Notice on Usage and Attribution</strong></p><p>These are personal class notes based on the University of Michigan EECS 498.008 / 598.008 course. They are intended solely for personal learning and academic discussion, with no commercial use.</p><p>For detailed information, please refer to the <strong><a href="#notice-on-usage-and-attribution">complete notice at the end of this document</a></strong></p><h2 id="visualizing-layers" tabindex="-1"><a class="header-anchor" href="#visualizing-layers"><span>Visualizing layers</span></a></h2><h3 id="first-layer-visualize-filters" tabindex="-1"><a class="header-anchor" href="#first-layer-visualize-filters"><span>First layer: Visualize filters</span></a></h3><div style="text-align:center;margin-bottom:1em;"><img src="'+r+'" width="70%" alt="First layer: Visualize filters"><br> Fig: Convolutional filters on the first layer</div><p><a href="https://arxiv.org/abs/1404.5997" target="_blank" rel="noopener noreferrer">One weird trick for parallelizing convolutional neural networks</a></p><p>&quot;Template matching&quot;. Idea: inner product between filter and image region. Visualizing filters can give us some insight into what the network is looking for. Recall that Mammalian visual cortex has simple cells and complex cells. Simple cells are edge detectors, complex cells are invariant to position.</p><h3 id="higher-layers" tabindex="-1"><a class="header-anchor" href="#higher-layers"><span>Higher Layers</span></a></h3><div style="text-align:center;margin-bottom:1em;"><img src="'+s+'" width="70%" alt="Higher Layers: Visualize Filters"><br>Figs: Filters on higher layers</div><p>Intermediate convolutional layers are more difficult to interpret.</p><h3 id="last-layer" tabindex="-1"><a class="header-anchor" href="#last-layer"><span>Last Layer</span></a></h3><p>Run the network on an image and visualize the activations of the last layer.</p><h4 id="nearest-neighbors" tabindex="-1"><a class="header-anchor" href="#nearest-neighbors"><span>Nearest Neighbors</span></a></h4><div style="text-align:center;margin-bottom:1em;"><img src="'+o+'" width="70%" alt="Nearest Neighbors"><br>Fig: Nearest Neighbors</div><p>All of the nearest neighbors are of the same class. This is a good sign that the low-level pixel content are ignored and the network is focusing on the high-level content.</p><h4 id="dimensionality-reduction-pca-t-sne" tabindex="-1"><a class="header-anchor" href="#dimensionality-reduction-pca-t-sne"><span>Dimensionality Reduction: PCA/t-SNE</span></a></h4><div style="text-align:center;margin-bottom:1em;"><img src="'+c+'" width="70%" alt="Dimensionality Reduction: PCA"><br>Fig: Dimensionality Reduction: PCA</div><p>t-SNE is a more complex method that tries to preserve the local structure of the data.</p><p>The ten clusters are correspond to the ten classes of MNIST.</p><p>See also <a href="http://cs.stanford.edu/people/karpathy/cnnembed/" target="_blank" rel="noopener noreferrer">high-resolution version</a>. (Recommended, really interesting)</p><h2 id="visualizing-activations" tabindex="-1"><a class="header-anchor" href="#visualizing-activations"><span>Visualizing Activations</span></a></h2><p>Idea: Given an image, visualize the activations of the network at each layer. This gives a sense of what the neurons might be responding to.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+l+'" width="70%" alt="Visualizing Activations"><br>Fig: Visualizing Activations</div><p>Why are there so many zeros ? Because of the ReLU activation function. The way to squash the image might also have an effect on the visualization.</p><h2 id="maximally-activating-patches" tabindex="-1"><a class="header-anchor" href="#maximally-activating-patches"><span>Maximally Activating Patches</span></a></h2><p>Run the model on all images, and for a given neuron, find the images that maximally activate that neuron.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+g+'" width="70%" alt="Maximally Activating Patches"><br>Fig: Maximally Activating Patches</div><h2 id="saliency-via-occlusion" tabindex="-1"><a class="header-anchor" href="#saliency-via-occlusion"><span>Saliency via Occlusion</span></a></h2><p>Pass the masked image through the network and see how the output changes.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+m+'" width="70%" alt="Saliency via Occlusion"><br>Fig: Saliency via Occlusion</div><p>Computationally expensive.</p><h2 id="saliency-via-backpropagation" tabindex="-1"><a class="header-anchor" href="#saliency-via-backpropagation"><span>Saliency via backpropagation</span></a></h2><p>Compute the gradient of the output with respect to the <strong>input</strong>.</p><p>This represents if we change the pixels a little bit, how much would it affect the score at the end.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+p+'" width="70%" alt="Saliency via backpropagation"><br>Fig: Saliency via backpropagation</div><p>(Most real examples do not look this good)</p><h2 id="saliency-maps-segmentation-without-supervision" tabindex="-1"><a class="header-anchor" href="#saliency-maps-segmentation-without-supervision"><span>Saliency Maps: Segmentation without supervision</span></a></h2><p>We can use classification models to generate segmentation masks.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+d+'" width="70%" alt="Saliency Maps: Segmentation without supervision"><br>Fig: Saliency Maps: Segmentation without supervision</div><h2 id="gradient-information-for-intermediate-layers" tabindex="-1"><a class="header-anchor" href="#gradient-information-for-intermediate-layers"><span>Gradient information for intermediate layers</span></a></h2><p>Intermediate Features via (guided) backpropagation. The idea is similar to saliency via backpropagation, but if we do it directly, the results will be noisy. Instead, we use &quot;guided backpropagation&quot; to get cleaner results.</p><p>In forward pass, negative values are clamp to zero, and the gradients of the negative values are set to zero. In the backward pass, we also add a ReLU to the gradients, so that only positive gradients are propagated back. (Heuristic that works in practice)</p><div style="text-align:center;margin-bottom:1em;"><img src="'+h+'" width="70%" alt="Guided Backpropagation"></div><div style="text-align:center;margin-bottom:1em;"><img src="'+u+'" width="70%" alt="Guided Backpropagation"><br>Fig: Guided Backpropagation</div><h2 id="gradient-ascent" tabindex="-1"><a class="header-anchor" href="#gradient-ascent"><span>Gradient Ascent</span></a></h2><p>Generate an image that maximizes the activation of a neuron (using gradient ascent).</p><p>Initialize original image to zero, and then update the image to maximize the activation of a neuron.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+v+'" width="70%" alt="Gradient Ascent"><br>Fig: Gradient Ascent</div><p>Using other regularizers:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+y+'" width="70%" alt="Gradient Ascent"><br>Fig: Gradient Ascent</div><p>Use the same approach to visualize intermediate features:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+f+'" width="70%" alt="Gradient Ascent"><br>Fig: Gradient Ascent</div><h2 id="adversarial-examples" tabindex="-1"><a class="header-anchor" href="#adversarial-examples"><span>Adversarial Examples</span></a></h2><p>If we do not add regularizers, we can generate adversarial examples that looks like noise but can fool the network.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+b+'" width="70%" alt="Adversarial Examples"><br>Fig: Adversarial Examples</div><h2 id="feature-inversion" tabindex="-1"><a class="header-anchor" href="#feature-inversion"><span>Feature Inversion</span></a></h2><ul><li><strong>Feature Inversion</strong>: Given a <strong>feature vector</strong>, by minimizing the difference between the new input feature and the original feature, <strong>reconstruct</strong> an input data (such as an image).</li><li><strong>Gradient Ascent</strong>: By adjusting the input data, <strong>maximize the activation value of a specific neuron</strong>, and generate an input that maximizes the activation value of the neuron.</li></ul><div style="text-align:center;margin-bottom:1em;"><img src="'+x+'" width="70%" alt="Feature Inversion"><br>Fig: Feature Inversion</div><div style="text-align:center;margin-bottom:1em;"><img src="'+w+'" width="70%" alt="Feature Inversion"><br>Fig: Feature Inversion</div><p>As we go up through the network, the overall structure is preserved but the details are lost. e.g. textures</p><h2 id="deepdream-amplifying-existing-features" tabindex="-1"><a class="header-anchor" href="#deepdream-amplifying-existing-features"><span>DeepDream: Amplifying existing features</span></a></h2><p>Take an existing image and amplify the features that are already present in the image.</p><p>Idea: Start with an image, run it through the network, and then update the image to maximize the activation of a neuron.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+_+'" width="70%" alt="DeepDream"><br>Fig: DeepDream</div><p>This needs to get good regularizers to get good results.</p><p>DeepDream to lower layer networks:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+S+'" width="70%" alt="DeepDream"><br>Fig: DeepDream</div><p>Higher layers:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+T+'" width="70%" alt="DeepDream"><br>Fig: DeepDream</div><p>Patterns are shown out over and over again.</p><p>DeepDream for a long time:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+k+'" width="70%" alt="DeepDream"><br>Fig: DeepDream</div><div style="text-align:center;margin-bottom:1em;"><img src="'+z+'" width="70%" alt="DeepDream"><br>Fig: DeepDream</div><h2 id="application-texture-synthesis" tabindex="-1"><a class="header-anchor" href="#application-texture-synthesis"><span>Application: Texture Synthesis</span></a></h2><p>Nearest Neighbor: SIGGRAPH 2000</p><p>Gram Matrix: Correlation. This tells us which features tends to co-occur in the input image. We can perform texture synthesis by matching the Gram matrix using gradient ascent.</p><p>Since Gram Matrices are invariant to translation, we can expect to generate textures that are invariant to translation.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+A+'" width="70%" alt="Texture Synthesis"><br>Fig: Texture Synthesis</div><div style="text-align:center;margin-bottom:1em;"><img src="'+F+'" width="70%" alt="Texture Synthesis"><br>Fig: Texture Synthesis</div><div style="text-align:center;margin-bottom:1em;"><img src="'+N+'" width="70%" alt="Texture Synthesis"><br>Fig: Texture Synthesis</div><h2 id="application-style-transfer" tabindex="-1"><a class="header-anchor" href="#application-style-transfer"><span>Application: Style Transfer</span></a></h2><p>Feature + Gram Joint Reconstruction</p><p>Content Image + Style Image</p><p>CVPR 2016</p><div style="text-align:center;margin-bottom:1em;"><img src="'+C+'" width="70%" alt="Style Transfer"><br>Fig: Style Transfer</div><div style="text-align:center;margin-bottom:1em;"><img src="'+D+'" width="70%" alt="Style Transfer"><br>Fig: Style Transfer</div><p>We can toggle the weight between the content and style images to get different results.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+G+'" width="70%" alt="Style Transfer"><br>Fig: Style Transfer</div><p>Multiple Image Style Transfer:</p><div style="text-align:center;margin-bottom:1em;"><img src="'+I+'" width="70%" alt="Style Transfer"><br>Fig: Style Transfer</div><p>Problem: Super slow. Style transfer requires many forward/backward passes through VGG; very slow!</p><p>Solution: Train another neural network to perform style transfer.</p><div style="text-align:center;margin-bottom:1em;"><img src="'+V+'" width="70%" alt="Style Transfer"><br>Fig: Style Transfer</div><h2 id="notice-on-usage-and-attribution" tabindex="-1"><a class="header-anchor" href="#notice-on-usage-and-attribution"><span><strong>Notice on Usage and Attribution</strong></span></a></h2><p>This note is based on the <strong>University of Michigan&#39;s publicly available course EECS 498.008 / 598.008</strong> and is intended <strong>solely for personal learning and academic discussion</strong>, with no commercial use.</p><ul><li><strong>Nature of the Notes:</strong> These notes include extensive references and citations from course materials to ensure clarity and completeness. However, they are presented as personal interpretations and summaries, not as substitutes for the original course content.</li><li><strong>Original Course Resources:</strong> Please refer to the official <a href="https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/" target="_blank" rel="noopener noreferrer"><strong>University of Michigan website</strong></a> for complete and accurate course materials.</li><li><strong>Third-Party Open Access Content:</strong> This note may reference Open Access (OA) papers or resources cited within the course materials. These materials are used under their original Open Access licenses (e.g., CC BY, CC BY-SA).</li><li><strong>Proper Attribution:</strong> Every referenced OA resource is appropriately cited, including the author, publication title, source link, and license type.</li><li><strong>Copyright Notice:</strong> All rights to third-party content remain with their respective authors or publishers.</li><li><strong>Content Removal:</strong> If you believe any content infringes on your copyright, please contact me, and I will promptly remove the content in question.</li></ul><p>Thanks to the <strong>University of Michigan</strong> and the contributors to the course for their openness and dedication to accessible education.</p>',101)])])}const R=t(M,[["render",P]]),O=JSON.parse('{"path":"/notes/um-cv/um-cv-14/","title":"14 Visualizing and understanding CNNs","lang":"en-US","frontmatter":{"title":"14 Visualizing and understanding CNNs","tags":["notes","computer-vision"],"createTime":"2024/12/27 16:08:15","permalink":"/notes/um-cv/um-cv-14/","outline":[2,4],"description":"Various techniques to visualize and understand CNNs. Activations: Nearest neighbors, PCA, t-SNE, saliency, occlusion, backpropagation. Gradients: Saliency maps, class visualizat...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14 Visualizing and understanding CNNs\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-21T17:44:17.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://saturntsen.github.io/notes/um-cv/um-cv-14/"}],["meta",{"property":"og:site_name","content":"SaturnTsen"}],["meta",{"property":"og:title","content":"14 Visualizing and understanding CNNs"}],["meta",{"property":"og:description","content":"Various techniques to visualize and understand CNNs. Activations: Nearest neighbors, PCA, t-SNE, saliency, occlusion, backpropagation. Gradients: Saliency maps, class visualizat..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-21T17:44:17.000Z"}],["meta",{"property":"article:tag","content":"computer-vision"}],["meta",{"property":"article:tag","content":"notes"}],["meta",{"property":"article:modified_time","content":"2025-02-21T17:44:17.000Z"}]]},"readingTime":{"minutes":6.02,"words":1807},"git":{"createdTime":1735477870000,"updatedTime":1740159857000,"contributors":[{"name":"SaturnTsen","username":"SaturnTsen","email":"minger233@outlook.com","commits":4,"avatar":"https://avatars.githubusercontent.com/SaturnTsen?v=4","url":"https://github.com/SaturnTsen"}]},"autoDesc":true,"filePathRelative":"notes/UM-CV/UM-CV 14 Visualizing and understanding CNNs.md","headers":[],"categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"31a781","sort":10004,"name":"UM-CV"}]}');export{R as comp,O as data};
